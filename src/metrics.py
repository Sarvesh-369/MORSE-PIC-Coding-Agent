import os
import subprocess
import uuid
import shutil
import tempfile
import glob
import torch
import torch.nn.functional as F
from PIL import Image
from transformers import AutoImageProcessor, AutoModel

# Global model and processor to load only once
_PROCESSOR = None
_MODEL = None
_DEVICE = "cuda" if torch.cuda.is_available() else "cpu"

def get_model_and_processor():
    global _PROCESSOR, _MODEL, _DEVICE
    if _PROCESSOR is None or _MODEL is None:
        print(f"Loading DINOv3 model on {_DEVICE}...")
        model_name = "facebook/dinov3-vits16-pretrain-lvd1689m"
        try:
            _PROCESSOR = AutoImageProcessor.from_pretrained(model_name)
            _MODEL = AutoModel.from_pretrained(model_name).to(_DEVICE)
        except OSError:
            # Fallback to a standard vit if the specific dinov3 checkpoint is private/unavailable 
            # despite the search result saying it exists. 
            # But we will trust the user and try the logical one first.
            # If it fails, the user might need to auth or change model name.
            print(f"Warning: Could not load {model_name}. Ensure you have access.")
            raise
    return _PROCESSOR, _MODEL

def get_embedding(image_path):
    processor, model = get_model_and_processor()
    try:
        image = Image.open(image_path).convert("RGB")
    except Exception as e:
        print(f"Error opening image {image_path}: {e}")
        return None

    inputs = processor(images=image, return_tensors="pt").to(_DEVICE)
    with torch.no_grad():
        outputs = model(**inputs)
    
    # Extract [CLS] token embedding (first token)
    # output.last_hidden_state shape: [batch, sequence_length, hidden_size]
    cls_embedding = outputs.last_hidden_state[:, 0, :]
    return cls_embedding

def visual_similarity_metric(gold, pred, trace=None):
    """
    Calculates visual similarity between the reference image (gold.image_path)
    and the image generated by the predicted code (pred.code).
    """
    reference_image_path = gold.image_path
    generated_code = pred.code
    
    if not generated_code:
        return 0.0

    # 1. Clean code
    clean_code = generated_code.strip()
    if clean_code.startswith("```python"):
        clean_code = clean_code[9:]
    elif clean_code.startswith("```"):
        clean_code = clean_code[3:]
    if clean_code.endswith("```"):
        clean_code = clean_code[:-3]
    
    # 2. Setup sandbox environment
    # Create a unique temp directory for this execution to isolate outputs
    with tempfile.TemporaryDirectory() as temp_dir:
        script_path = os.path.join(temp_dir, f"temp_gen_{uuid.uuid4().hex}.py")
        
        # Write code to file
        with open(script_path, "w") as f:
            f.write(clean_code)
            
        # 3. Execute code
        try:
            # Run in the temp directory so outputs land there
            subprocess.run(
                ["python3", script_path], 
                cwd=temp_dir, 
                timeout=15, 
                check=True,
                stdout=subprocess.DEVNULL, 
                stderr=subprocess.DEVNULL
            )
        except (subprocess.TimeoutExpired, subprocess.CalledProcessError):
            # If code fails or times out, score is 0
            return 0.0
        except Exception:
            return 0.0

        # 4. Find generated image
        # Look for any png file created in the temp dir
        generated_images = glob.glob(os.path.join(temp_dir, "*.png"))
        if not generated_images:
            # Try jpg as fallback
            generated_images = glob.glob(os.path.join(temp_dir, "*.jpg"))
            
        if not generated_images:
            return 0.0
        
        # Take the most recently modified file or just the first one
        generated_image_path = generated_images[0]
        
        # 5. Calculate Similarity
        ref_emb = get_embedding(reference_image_path)
        gen_emb = get_embedding(generated_image_path)
        
        if ref_emb is None or gen_emb is None:
            return 0.0
            
        # Cosine similarity
        similarity = F.cosine_similarity(ref_emb, gen_emb)
        score = similarity.item()
        
        # Ensure score is 0.0 to 1.0 (cosine sim is -1 to 1, but images shouldn't be negative usually)
        # We can map it or just clip. For now, raw cosine similarity is often used.
        # But for DSPy metric 0-1 is best.
        return max(0.0, score)
